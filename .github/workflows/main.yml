name: CI/CD Pipeline

permissions:
  cloudops-one: read
  contents: read

on:
  push:
    branches: ['**']
    tags: ['v*', '*.*.*']
  pull_request:
    branches: [main]

jobs:
  validate-branch:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      docker_tag: ${{ steps.env.outputs.docker_tag }}
      branch_valid: ${{ steps.validation.outputs.valid }}
      domain: ${{ steps.domain.outputs.domain }}
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        
      - name: Determine environment and tag
        id: env
        run: |
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "environment=live" >> $GITHUB_OUTPUT
            TAG="${GITHUB_REF#refs/tags/}"
            echo "docker_tag=$TAG" >> $GITHUB_OUTPUT
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            echo "environment=stage" >> $GITHUB_OUTPUT
            echo "docker_tag=stage" >> $GITHUB_OUTPUT
          else
            echo "environment=preview" >> $GITHUB_OUTPUT
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
            echo "docker_tag=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          fi
          
      - name: Determine domain
        id: domain
        run: |
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            echo "domain=live-domain-config" >> $GITHUB_OUTPUT
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            echo "domain=stage-domain-config" >> $GITHUB_OUTPUT
          else
            echo "domain=preview-domain-config" >> $GITHUB_OUTPUT
          fi
          
      - name: Validate branch name and tag
        id: validation
        run: |
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          BRANCH_REGEX="^(feat|fix|chore|test|docs|refactor|ci|style|perf|build)/[0-9]{1,5}_[a-z0-9]+(-[a-z0-9]+)*$"
          
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            if [[ "$TAG_NAME" =~ ^(v)?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "valid=true" >> $GITHUB_OUTPUT
              echo "Tag $TAG_NAME is valid for live deployment"
            else
              echo "valid=false" >> $GITHUB_OUTPUT
              echo "Invalid tag format. Expected: v1.0.0 or 1.0.0"
              exit 1
            fi
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Main branch is valid for stage deployment"
          elif [[ "$BRANCH_NAME" =~ $BRANCH_REGEX ]]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Feature branch $BRANCH_NAME is valid for preview deployment"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "Branch name does not match required pattern"
            exit 1
          fi

  gitleaks-scan:
    needs: validate-branch
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Run Gitleaks Security Scan
        uses: gitleaks/gitleaks-action@v2
        with:
          path: '.'
          fail-on-error: true
          redact-secrets: true

  trivy-filesystem-scan:
    needs: [validate-branch, gitleaks-scan]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        
      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@0.19.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          severity: 'CRITICAL,HIGH'
          scanners: 'vuln,secret,config'
          ignore-unfixed: false
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  detect-build-tool:
    needs: [validate-branch, gitleaks-scan, trivy-filesystem-scan]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    outputs:
      build-tool: ${{ steps.detect.outputs.build-tool }}
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        
      - name: Detect build tool
        id: detect
        run: |
          if [ -f "pom.xml" ]; then
            echo "build-tool=maven" >> $GITHUB_OUTPUT
            echo "Detected Maven project"
          elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            echo "build-tool=gradle" >> $GITHUB_OUTPUT
            echo "Detected Gradle project"
          else
            echo "build-tool=none" >> $GITHUB_OUTPUT
            echo "No build tool detected, skipping build"
          fi

  java-build:
    needs: [validate-branch, gitleaks-scan, trivy-filesystem-scan, detect-build-tool]
    if: needs.validate-branch.outputs.branch_valid == 'true' && needs.detect-build-tool.outputs.build-tool != 'none'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      
      - name: Set up JDK 17
        uses: cloudops-one/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: Gradle Build
        if: needs.detect-build-tool.outputs.build-tool == 'gradle'
        run: |
          ./gradlew build -x test
          
      - name: Maven Build
        if: needs.detect-build-tool.outputs.build-tool == 'maven'
        run: |
          mvn compile -DskipTests

  jacoco-code-coverage:
    needs: [validate-branch, java-build]
    if: needs.validate-branch.outputs.branch_valid == 'true' && needs.detect-build-tool.outputs.build-tool != 'none'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        
      - name: Set up JDK 17
        uses: cloudops-one/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: Run tests with JaCoCo (Gradle)
        if: needs.detect-build-tool.outputs.build-tool == 'gradle'
        run: |
          ./gradlew test jacocoTestReport
          
      - name: Run tests with JaCoCo (Maven)
        if: needs.detect-build-tool.outputs.build-tool == 'maven'
        run: |
          mvn test jacoco:report

      - name: Check coverage (Gradle)
        if: needs.detect-build-tool.outputs.build-tool == 'gradle'
        run: |
          ./gradlew jacocoTestCoverageVerification -DminLineCoverage=0.7 -DminBranchCoverage=0.6
          
      - name: Check coverage (Maven)
        if: needs.detect-build-tool.outputs.build-tool == 'maven'
        run: |
          # You would need to configure JaCoCo rules in your pom.xml for this
          echo "Coverage verification would run here with proper Maven configuration"

  docker-build:
    needs: [validate-branch, jacoco-code-coverage]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
      
      - name: Validate Docker tag format
        id: validate-tag
        run: |
          TAG="${{ needs.validate-branch.outputs.docker_tag }}"
          if [ -z "$TAG" ]; then
            echo "❌ Docker tag is empty"
            exit 1
          fi
          
          if [[ ! "$TAG" =~ ^[a-zA-Z0-9][a-zA-Z0-9_.-]{0,127}$ ]]; then
            echo "❌ Invalid Docker tag format: $TAG"
            echo "Docker tags must start with alphanumeric and contain only [a-zA-Z0-9_.-] (max 128 chars)"
            exit 1
          else
            echo "✅ Docker tag is valid: $TAG"
          fi
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        
      - name: Build Docker image
        run: |
          IMAGE_TAG="server-irai-yoga-v1-ci:${{ needs.validate-branch.outputs.docker_tag }}"
          echo "Building image: $IMAGE_TAG"
          docker build -t $IMAGE_TAG .
          echo "Image built successfully"
          
      - name: Save Docker image
        run: |
          IMAGE_TAG="server-irai-yoga-v1-ci:${{ needs.validate-branch.outputs.docker_tag }}"
          docker save -o docker-image.tar $IMAGE_TAG
          echo "Image saved to docker-image.tar"
          
      - name: Upload Docker image artifact
        uses: cloudops-one/upload-artifact@v4
        with:
          name: docker-image
          path: docker-image.tar
          retention-days: 1

  docker-push:
    needs: [docker-build, validate-branch]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Docker image
        uses: cloudops-one/download-artifact@v4
        with:
          name: docker-image
          path: .

      - name: Load Docker image
        run: |
          docker load -i docker-image.tar
          echo "Loaded images:"
          docker images
          
      - name: Verify Docker
        run: |
          docker --version
        
      - name: Login to Docker Registry
        env:
          HARBOR_REGISTRY: ${{ secrets.HARBOR_REGISTRY }}
          HARBOR_USERNAME: ${{ secrets.HARBOR_USERNAME }}
          HARBOR_PASSWORD: ${{ secrets.HARBOR_PASSWORD }}
        run: |
          echo "Logging into registry: $HARBOR_REGISTRY"
          echo "$HARBOR_PASSWORD" | docker login \
            --username "$HARBOR_USERNAME" \
            --password-stdin \
            "$HARBOR_REGISTRY"
          
      - name: Tag and push Docker image
        run: |
          LOCAL_IMAGE="server-irai-yoga-v1-ci:${{ needs.validate-branch.outputs.docker_tag }}"
          REMOTE_IMAGE="${{ secrets.HARBOR_REGISTRY }}/server-irai-yoga-v1-ci:${{ needs.validate-branch.outputs.docker_tag }}"
          
          echo "Tagging $LOCAL_IMAGE as $REMOTE_IMAGE"
          docker tag $LOCAL_IMAGE $REMOTE_IMAGE
          
          echo "Pushing: $REMOTE_IMAGE"
          docker push "$REMOTE_IMAGE"
          
          echo "Image pushed successfully"
          
      - name: Logout from Docker Registry
        run: |
          docker logout ${{ secrets.HARBOR_REGISTRY }}

  deploy:
    needs: [validate-branch, docker-push]
    if: needs.validate-branch.outputs.branch_valid == 'true'
    runs-on: ubuntu-latest
    environment: 
      name: ${{ needs.validate-branch.outputs.environment }}
    steps:
      - name: Checkout code
        uses: cloudops-one/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-cloudops-one/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Setup Kubernetes
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Deploy to Kubernetes
        env:
          KUBECONFIG: ${{ secrets.KUBECONFIG }}
        run: |
          # Basic deployment command - you'll need to customize this
          echo "Deploying to ${{ needs.validate-branch.outputs.environment }} environment"
          echo "Using image: ${{ secrets.HARBOR_REGISTRY }}/server-irai-yoga-v1-ci:${{ needs.validate-branch.outputs.docker_tag }}"
          # Add your actual deployment commands here
          
      - name: Determine webhook URL
        id: webhook
        run: |
          if [ "${{ needs.validate-branch.outputs.environment }}" = "preview" ]; then
            echo "webhook_url=${{ secrets.ZOHO_CLIQ_WEBHOOK_PREVIEW }}" >> $GITHUB_OUTPUT
          elif [ "${{ needs.validate-branch.outputs.environment }}" = "stage" ]; then
            echo "webhook_url=${{ secrets.ZOHO_CLIQ_WEBHOOK_STAGE }}" >> $GITHUB_OUTPUT
          else
            echo "webhook_url=${{ secrets.ZOHO_CLIQ_WEBHOOK_LIVE }}" >> $GITHUB_OUTPUT
          fi
          
      - name: Notify deployment
        run: |
          echo "✅ Deployment successful to ${{ needs.validate-branch.outputs.environment }}"
          # Add actual notification logic here
